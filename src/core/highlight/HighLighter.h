#ifndef HIGH_LIGHTER_H
#define HIGH_LIGHTER_H

#include <functional>
#include <optional>
#include <unordered_map>
#include <unordered_set>
#include <string_view>

#include <tree_sitter/api.h>

#include "../command/CommandManager.h"
#include "../cursor/buffer/BufferEdit.h"
#include "../cursor/Cursor.h"
#include "HighLightId.h"
#include "TokenId.h"


/**
 * @brief Syntax highlighter using Tree-sitter for structured code parsing.
 *
 * Manages language-specific parsers, applies syntax highlighting, and supports
 * dynamic language switching based on file extensions or user commands.
 */
class HighLighter final {
private:
    /**
     * @brief Holds language-specific parser data and mapping logic.
     */
    struct Parser final {
        using MapperFunction = std::function<TokenId(uint16_t)>;

        const TSLanguage* language;                         ///< Pointer to the Tree-sitter language definition.
        const std::string name;                             ///< Human-readable name of the language.
        const std::string argument_value;                   ///< Argument string usable in the prompt to select this parser.
        const std::unordered_set<std::string> files_format; ///< Set of supported file extensions for the language.
        const MapperFunction mapper_function;               ///< Function mapping Tree-sitter symbols to TokenIds.
    };

    /** The current active parser module, or nullptr. Is used only to avoid a map lookup for each character.  */
    const Parser* p_current_parser;

    /** The Tree-sitter parser instance. */
    TSParser* p_ts_parser;

    /** The syntax tree generated by parsing. */
    TSTree* p_ts_tree;

    /** Tree-sitter input wrapper for reading source text. */
    TSInput m_input;

    /** Currently active highlighting mode. */
    HighLightId m_high_light;

    /** Registered parsers indexed by highlighting mode. */
    std::unordered_map<HighLightId, Parser> m_parsers;

    /** Callback for reading text input. */
    std::function<std::optional<std::u16string_view>(uint32_t, uint32_t)> m_cb;

private:
    /** @brief Tree-sitter input callback used to supply source code to the parser. */
    static const char* inputCallback(void* payload, uint32_t byteIndex, TSPoint position, uint32_t* bytesRead);

    /**
     * @brief Registers the console command for setting the highlighting mode.
     * @param commandManager Reference to the command manager.
     */
    void registerHlCommand(CommandManager& commandManager);

    /** @brief Registers all available language parsers. */
    void registerParsers();

public:
    /** @brief Deleted copy constructor. */
    HighLighter(const HighLighter &) = delete;

    /** @brief Deleted copy assignment operator. */
    HighLighter &operator=(const HighLighter &) = delete;

    /** @brief Constructs the HighLighter with default values. */
    explicit HighLighter();

    /**
     * @brief Initializes the HighLighter, registering commands and parsers.
     * @param commandManager Reference to the command manager.
     */
    void create(CommandManager& commandManager);

    /** @brief Cleans up and releases all internal resources. */
    void destroy();

    /**
     * @brief Sets the current syntax highlighting mode explicitly.
     * @param highLight Highlight mode to activate.
     */
    void setMode(HighLightId highLight);

    /**
     * @brief Sets the highlighting mode based on file extension.
     * THis will fall back to no highlight if nothing matches.
     * @param extension File extension (including the dot), e.g. ".cpp".
     */
    void setMode(std::string_view extension);

    /**
     * @brief Binds a Cursor so that the HighLighter can read source code from it.
     * @param cursor Reference to the source Cursor.
     */
    void setInput(const Cursor& cursor);

    /**
     * @brief Parses or reparses the current input buffer.
     */
    void parse();

    /**
     * @brief Notifies the HighLighter about a range of text edits.
     * @param edit Object describing the modified byte and position ranges. (provided by the Cursor class)
     */
    void edit(const BufferEdit& edit) const;

    /**
     * @brief Retrieves all available parser names for use in the prompt.
     * @param callback Callback that receives each parser name.
     */
    void getParserNames(const ItemCallback<char>& callback) const;

    /**
     * @brief Checks whether a given file extension is supported.
     * @param extension File extension to query (including the dot).
     * @return true if a parser supports the given extension.
     */
    [[nodiscard]] bool isSupported(std::string_view extension) const;

    /**
     * @brief Retrieves the TokenId (syntax classification) at a specific position.
     * @param line Line number (zero-based).
     * @param column Column number (zero-based).
     * @return TokenId describing the syntax element at that position.
     */
    [[nodiscard]] TokenId getHighLightAtPosition(uint32_t line, uint32_t column) const;

    /** @return The current highlight mode name (e.g., "cpp", "json"). */
    [[nodiscard]] std::string_view getModeString() const;
};



#endif //HIGH_LIGHTER_H
